# 进程的操作

## 创建进程

```c
#include <unistd.h>
pid_t fork(void);
//函数执行后，产生两个进程，每个进程返回一个值，返回值为0则是子进程
//父进程返回子进程的进程号（>0的非零整数）
```

* 在 linux 中，一个进程必须是另外一个进程的子进程，或者说一个进程必须有父进程，
  但是可以没有子进程。
*  子进程继承了父进程的内容，包括父进程的代码，变量， pcb，甚至包括当前 PC 值。在
  父进程中， PC 值指向当前 fork 函数的下一条指令地址，**因此子进程也是从 fork 函数的**
  **下一条指令开始执行**。 **父子进程的执行顺序是不确定的，可能子进程先执行，也可能父**
  **进程先执行，取决于当前系统的调度**。
*  父子进程有独立的地址空间、独立的代码空间，互不影响， 就算父子进程有同名的全局
  变量，但是由于它们处在不同的地址空间，因此不能共享。
* 子进程结束之后，必须由它的父进程回收它的一切资源，否则就会成为**僵尸进程**。
*  如果父进程先结束，子进程会成为**孤儿进程**，它会被 **INIT** 进程收养， INIT 进程是内核
  启动之后，首先被创建的进程。  

## 结束进程

```c
#include <stdlib.h>
void exit(int status);//exit结束进程时会刷新缓冲区，将还在缓存区的数据写入文件

#include <unistd.h>
void _exit(int status);// _exit则是直接关闭文件，文件缓冲区的内容随即消失
```

> exit 和_exit 函数是返回给操作系统的
> return 函数是当前函数返回，**返回到调用它的函数中**，如果正好是在 main 函数中， return 函数也返回给了操作系统，这个时候 return 和 exit、 _exit 起到了类似的作用。  

## 回收进程

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
//返回值: 成功则返回子进程的进程号，失败返回-1

#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *status, int options);
//返回值: 成功则返回子进程的进程号，失败返回-1
```

